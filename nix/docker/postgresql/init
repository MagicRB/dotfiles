# -*- mode: shell-script; -*-

conf=$1 ; shift 1
source $conf

# shellcheck source=/../../bash-lib/main.bash
source $_prog_bashlib

$_prog_busybox/bin/cat <<EOF
### Postgresql Nix Image Manual
##
## USER_UID ? $_conf_user_uid - default user id
## USER_GID ? $_conf_user_gid - default group id
## USER - username for postgres superuser
## PASSWORD - password for postgres superuser
## INITDB_ARGS ? "" - passed to \`initdb\`
## [ INITDB_WALDIR ] - write-ahead log director
##
EOF

default_opt USER_UID "$_conf_user_uid"
default_opt USER_GID "$_conf_user_gid"
default_opt USER "$_conf_user"
default_opt PASSWORD "$_conf_password"
default_opt INITDB_ARGS ""
default_opt INITDB_WALDIR ""

$_prog_busybox/bin/cat <<EOF
### Starting with options:
## USER_UID = "$_user_uid"
## USER_GID = "$_user_gid"
## USER = "$_user"
## PASSWORD = "$_password"
## INITDB_ARGS = "$_initdb_args"
## INITDB_WALDIR = "$_initdb_waldir"
EOF

add_user "postgres:x:$_user_uid:$_user_gid:PostgreSQL:$_conf_data:$_prog_bash/bin/bash" "postgres:x:$_user_gid:"

[[ ! -d $_conf_data ]] && mkdir_chown $_conf_data "$_user_uid" "$_user_gid"
[[ ! -z "$_initdb_waldir" ]] && mkdir_chown $_initdb_waldir "$_user_uid" "$_user_gid"
mkdir_chown /tmp "$_user_uid" "$_user_gid"
mkdir_chown /run/postgresql "$_user_uid" "$_user_gid"

$_prog_busybox/bin/mkdir -p /usr/bin /bin
$_prog_busybox/bin/ln -s $_prog_busybox/bin/env /usr/bin/env
$_prog_busybox/bin/ln -s $_prog_busybox/bin/sh /bin/sh

create_ssl_certs $_conf_cacert

_db_exists=$([[ -s "$_conf_data/PG_VERSION" ]] && echo 0 || echo 1 )

function execAs() {
    user="$1"; shift
    cmd="$1"; shift
    $_prog_busybox/bin/su "$user" -s "$($_prog_busybox/bin/which -- "$cmd")" -- "$@"
}

function start_tmp_server() {
    PGUSER="$_user" execAs postgres $_prog_postgresql/bin/pg_ctl \
	  -D "$_conf_data" \
	  -o '-c listen_addresses="" -p "5432"' \
	  -w start
}

function stop_tmp_server() {
    PGUSER="$_user" execAs postgres $_prog_postgresql/bin/pg_ctl \
	  -D "$_conf_data" \
	  -m fast \
	  -w stop
}

# Execute sql script, passed via stdin (or -f flag of pqsl)
# usage: docker_process_sql [psql-cli-args]
#    ie: docker_process_sql --dbname=mydb <<<'INSERT ...'
#    ie: docker_process_sql -f my-file.sql
#    ie: docker_process_sql <my-file.sql
process_psql() {
    PGHOST= PGHOSTADDR= execAs postgres $_prog_postgresql/bin/psql -v ON_ERROR_STOP=1 --username "$_user" --no-password "$@"
}

export PATH=$_prog_postgresql/bin # I don't like it, but postgres does
# Intialize database or reset username and password
if [[ $_db_exists = "1" ]]
then
    echo "No database exists yet, proceding to create one!"

    PGDATA=$_conf_data execAs postgres $_prog_bash/bin/bash <<EOF
    $_prog_postgresql/bin/initdb \
        --username="$_conf_user" \
        --pwfile=<(echo "$_password") \
        $([[ ! -z "$_initdb_waldir" ]] && echo "--waldir $_initdb_waldir") \
        $_initdb_args \
        --pgdata="$_conf_data"
EOF

    echo "$_conf_user" > "$_conf_data/user_save"
else
    echo "Database already exists, attempting to recreate user and set correct password!"
    start_tmp_server

    _old_username="$($_prog_busybox/bin/cat $_conf_data/user_save)"
    if [[ "$_old_username" = "$_user" ]]
    then
	process_psql "postgres" -c "ALTER USER $_user WITH PASSWORD '$_password';"
    else
	process_psql "postgres" -c "CREATE USER $_user; ALTER USER $_user WITH PASSWORD '$_password' AND SUPERUSER; DROP USER $_old_username"
	echo "$_conf_user" > "$_conf_data/user_save"
    fi

    stop_tmp_server
fi

if [[ -d /data/scripts ]]
then
    start_tmp_server

    for script in /data/scripts/*.sh
    do
	(
	    echo "Running \`$script\`."
	    export -f process_psql execAs
	    export PATH=$_prog_bash/bin/:$_prog_busybox/bin/:$_prog_postgresql/bin/ _prog_bash _prog_busybox _prog_postgresql
	    bash $script
	)
    done

    stop_tmp_server
fi

PGDATA=$_conf_data \
    execAs postgres $_prog_postgresql/bin/postgres
